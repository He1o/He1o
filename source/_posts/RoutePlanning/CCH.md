---
title: Customizable Contraction Hierarchies
date: 2025-07-13
category: Route Planning
katex: true
---
<!--more-->

# 2 Basics

定义一个 $n$ 个顶点的无向图 $G=(V,E)$，其中 $V$ 是顶点的的集合，$E$ 是边的集合，进一步 $G=(V,A)$ 代表一个有向图，$A$ 是弧的集合（注：edge 用来表示无向的边，arc 表示有向的边）。如果一个图没有 $loops$ ($a-a$)和多重边(同时存在 $aa',aa,a=a'$)，则称为一个简单图。在本文中除非另有说明，则都为简单图。此外，我们假设图都是强联通的。我们使用 $N(v)$ 代表顶点 $v\in G$ 的相邻顶点的集合，对于有向图忽略邻接节点的方向。一个顶点分离器 (vertex separator) 是一个顶点的子集合 $S \subseteq V$，其将 $G$ 分离成不连接的两个子图分别包含着顶点集合 $A$ 和 $B$，集合 $S$ 和 $A$ 和 $B$ 是不相交的，它们联合组成了 $V$。$A$ 和 $B$ 的子图不一定连接并且可能是空的，如果 $|A|,|B|\le 2n/3$，则称分离器 $S$ 是平衡的。

一个顶点顺序 $\pi:\{1\dots n\}\rightarrow V$ 是双射的，它的逆 $\pi^{-1}$ 分配给每个节点一个排名 $rank$。每个无向图可以通过顶点顺序 $\pi$ 转换为一个向上有向图(upward directed graph)，每条边 $\{\pi(i),\pi(j)\}$ 当 $i<j$ 时可以被弧 $(\pi(i),\pi(j))$ 所取代，所有向上有向图都是无环的。我们使用 $N_u(v)$ 表示 $v$ 向上的邻居节点，这些 $v$ 的邻居节点比其具有更高的 $rank$，同样使用 $N_d(v)$ 代表 $v$ 向下的邻居节点。使用 $d_u(v)=|N_u(v)|$ 带边向上的度，同样 $d_d(v)=|N_d(v)|$ 代表向下的度数。

使用 $w:E\rightarrow \mathbb{R}_{>0}$ 代表无向边的权重。关于顶点的顺序 $\pi$ 我们定义一个向上的权重 $w_u:E\rightarrow \mathbb{R}_{>0}$ 和一个向下的权重 $w_d:E\rightarrow \mathbb{R}_{>0}$，对于有向图，单向街道通过将权重设置为无穷大。

一个路径 $P$ 是一系列相邻的顶点和入射的边组成。它的跳数长度 $hop-length$ 是 $P$ 中边的数量。它的权重长度 $weight-length$ 是所有边权重的总和 $w$。最短路径 $st-path$ 是顶点 $s$ 到 $t$ 最小长度的路径，使用 $\text{dist}_G(s,t)$ 表示，如果没有路径存在则设为无穷大。对于一个路径 $P$ 可以分为一个向上的路径 $P_u$ 和一个向下的路径 $P_d$。向上的路径必须遵守递增的 $rank$ $\pi^{-1}$ 顶点顺序，向下的路径必须遵循递减的 $rank$ $\pi^{-1}$ 顶点顺序。向上和向下的路径在最大 $rank$ 的顶点相遇，我们称这个顶点为相遇顶点。

每个有向无环图 (DAG) 的顶点可以分为级别 $levels$ $\ell:V\rightarrow \mathbb{N}$，对于每个弧 $(x,y)$ 都认为 $\ell(x)<\ell(y)$，我们只考虑每个顶点最低可能的等级。在有向无环图中可以以线性时间计算。

$G$ 中的 $v$ 的未加权的节点收缩包含移除 $v$ 和所有的关联的边，并且如果邻居节点 $N(v)$ 还未处理则插入边。插入的边称为 $shortcut$，其他的边称为原始边。给定一个顶点顺序 $\pi$，则根据等级顺序收缩节点 $\pi(0)\dots \pi(i-1)$ 就可以得到核心图 $G_{\pi,i}$。我们称原始图 $G$ 通过捷径的集合得到一个收缩层次结构 $G^*_{\pi}=\bigcup_iG_{\pi,i}$。此外，我们使用 $G^\wedge_s$ 表示相应的向上有向图。

给定一个固定权重$w$，可以利用以下性质进行优化：在许多应用中，只需保持所有最短路径的距离不变即可（而不需要精确维护原始图的所有结构）。顶点 $v$ 在 $G$ 中的加权节点收缩被定义为移除顶点 $v$，并在 $v$ 的邻居节点中插入最短路径的捷径，使收缩后的图 $G'$ 最短路径不变，对于所有的顶点 $x,y\neq v$ 都有 $\text{dist}_G(x,y)=\text{dist}_{G'}(x,y)$。计算 $G'$，需要对 $v$ 的所有邻居对 $x,y$ 根据 $\text{dist}_G(x,y)$ 递增的进行处理。对于每一对检查是否在 $G \{v\}$存在一个最短路 $xy-path$ 长度等于 $\text{dist}_G(x,y)$，即检查移除 $v$ 是否会破坏这条最短路。这个检查称作见证搜索，这条路径称作 $witness$，如果 $witness$ 被发现则认为这个顶点对可以被忽略，然后不需要添加 $shortcut$。否则的话，如果 $\{x,y\}$ 边已经存在，其权重更新为 $\text{dist}_G(x,y)$，如果不存在则添加一个 *shortcut* 到 $G$ 中（注：即不存在平行边），这个新的 *shortcut* 会在 $G$ 之后的见证搜索中考虑。如果最短路径不唯一，那么按照 $\text{dist}_G(x,y)$ 的距离递增顺序来遍历节点对就非常重要，否则可能会插入超出必要数量的边：较短的捷径会使较长的捷径变得多余（注：收缩一个节点的时候，优先收缩 dist 小的，这样那个长的也许就不必要添加）。然而，如果我们在较长的捷径之后才插入较短的捷径，见证路径搜索将不会考虑这些较短的捷径。图2提供了一个示例。需要注意的是，见证路径搜索的计算成本很高，因此通常会在达到一定步数后中止搜索。如果在此之前未找到见证路径，我们便假定不存在见证路径并添加一条捷径。这不会影响技术的正确性，但可能会导致插入的捷径数量略多于必要值。为作区分，完美的见证路径搜索不存在这种单方面误差。

对于顺序 $\pi$ 和权重 $w$，加权核心图 $G_{w,\pi,i}$ 通过收缩所有顶点 $\pi(1) \ldots \pi(i-1)$ 得到。原始图 $G$ 加上加权捷径集合后称为加权收缩层次 $G^*_{w,\pi}$。其对应的向上有向图记为 $G^\wedge_{w,\pi}$。

顶点 $v$ 的搜索空间 $SS(v)$ 是 $G^\wedge_\pi$（或 $G^\wedge_{w,\pi}$）中可从 $v$ 到达的子图。对于任意顶点对 $s$ 和 $t$，已证明必然存在一条最短的上下路径。这条上下路径可以通过从 $s$ 限制在 $SS(s)$ 内和从 $t$ 限制在 $SS(t)$ 内运行双向搜索来找到[21]。如果对于每个至少包含四个顶点的环，都存在一对在环中不相邻但通过边连接的顶点，则该图是弦图。另一种刻画方式是：存在一个顶点顺序 $\pi$，使得对于每个 $i$，$\pi(i)$ 在 $G_{\pi,i}$（即在收缩 $\pi(i)$ 之前的核心图）中的邻居构成一个团[19]（注：团指的是一个图中一个顶点子集，其中任意两个不同的顶点之间都有一条边相连。也就是说，这个子集对应的子图是一个完全图。）。这样的顺序称为完美消除顺序。在收缩层次术语中，这种刻画可以表述为：当且仅当存在一个收缩顺序，使得无需见证搜索的收缩层次构造过程不会插入任何捷径时，该图是弦图。通过添加收缩层次捷径可以得到一个弦超图。（注：弦图可以通过一个特定的顺序（完美消除顺序）被逐步“分解”成一系列相互连接的团。）

消除树 $T_{G,\pi}$ 是一棵指向其根节点 $\pi(n)$ 的有向树。顶点 $\pi(i)$ 的父节点是其向上邻居 $v \in N_u(\pi(i))$ 中具有最小秩 $\pi^{-1}(v)$ 的顶点。注意，该定义已经提供了构建消除树的直接算法。如[6]所示，从 $v$ 到 $\pi(n)$ 的路径上的顶点集合就是 $SS(v)$ 中的顶点集合。无见证搜索的图 $G$ 的收缩层次计算，实质上是计算具有完美消除顺序 $\pi$ 的弦超图 $G^*_\pi$。消除树的高度对应于搜索空间中的最大顶点数。注意，消除树仅针对无向无权图定义。

# 3 Metric-Dependent Orders
大多数关于收缩层次应用和扩展的出版物都使用基于[21]思想的贪心顺序，但顶点顺序计算和见证搜索的细节各不相同。为了可重现性，我们在本节中描述我们的精确方法，扩展第2节中给出的度量依赖的CH预处理的一般描述。

我们的见证搜索一旦找到比捷径短的路径就会中止——或者当向前和向后搜索各自最多访问了 $p$ 个顶点时中止。在大多数实验中我们选择 $p = 50$。唯一的例外是道路图上的距离度量，我们设置 $p = 1500$。我们发现较高的 $p$ 值会增加每次见证搜索的时间，但会导致更稀疏的核心。对于距离度量，我们需要较高的值，否则我们的核心会变得过于密集。这种效应在实验中考虑的其他权重中并未出现。

我们的权重启发式方法与[2]类似。我们用 $L(x)$ 表示近似顶点 $x$ 的层级的值。初始时所有 $L(x)$ 都为 0。如果 $x$ 被收缩，那么对于每个关联的边 ${x, y}$，我们执行 $\ell(y) \leftarrow \max\{\ell(y), \ell(x) + 1\}$。

我们进一步为每个弧 $a$ 存储一个跳数长度 $h(a)$。这是如果完全展开时代替的弧的数量。

用 $D(x)$ 表示如果 $x$ 被收缩时移除的弧集合，用 $A(x)$ 表示插入的弧集合。注意，由于见证搜索和一些边可能已经存在，$A(x)$ 不一定是完整的团。

我们贪心地收缩一个最小化其重要性 $I(x)$ 的顶点 $x$，其中 $I(x)$ 定义为

$$
I(x) = L(x) + \frac{|A(x)|}{|D(x)|} + \frac{\sum_{a \in A(x)} h(a)}{\sum_{a \in D(x)} h(a)}
$$

我们维护一个包含所有顶点（按重要性 $I$ 加权）的优先队列。初始时所有顶点都按其精确的重要性值插入队列。只要队列非空，我们就移除具有最小重要性 $I(x)$ 的顶点 $x$ 并收缩它。这一操作会改变其他顶点的重要性值。然而，如果见证搜索是完美的，我们选择的加权函数确保只有相邻顶点的重要性会受到影响。因此，我们只更新队列中所有与 $x$ 相邻的顶点 $y$ 的重要性值 $I(y)$。在实践中，由于见证搜索的限制，我们有时会选择重要性 $I(x)$ 稍次优的顶点 $x$。然而，初步实验表明这种影响可以安全忽略。因此，在第9节展示的实验中，我们没有使用[21]中提出的惰性更新或定期队列重建策略。

# 4 Metric-Independent Orders
前一节提出的度量依赖顺序在采用旅行时间度量的道路图上能产生优异的结果。然而，如第9节实验所示，对于距离度量而言效果欠佳，且该顺序在不使用见证搜索的收缩层次计算中完全不具可行性。为支持度量无关性，我们采用[6]中提出的**嵌套剖分顺序**，简称ND顺序。

图 $G$ 的顺序 $\pi$ 通过递归方式计算：首先确定一个将 $G$ 划分为由顶点集 $A$ 和 $B$ 诱导的两部分的最小基数平衡分离器 $S$。将 $S$ 中的顶点以任意顺序分配给 $\pi(n-|S|) \ldots \pi(n)$。递归计算顺序 $\pi_A$ 和 $\pi_B$，分别分配给 $\pi(1) \ldots \pi(|A|)$ 和 $\pi(|A|+1) \ldots \pi(|A|+|B|)$。当子图为空时达到递归的基本情况。计算 ND 顺序需要良好的图二分器，这在理论上是 NP 难的。


然而，近年来出现的启发式算法即使对于大陆规模的公路图也能很好地解决该问题[34,15,14]。这证明了在我们特定背景下假设存在高效二分预言机的合理性。我们将在第9节通过实验评估由 NDMetis[28] 和 KaHIP[34] 计算的嵌套剖分顺序的性能。获得嵌套剖分顺序后，我们相应地重新排列输入图的内存中顶点ID，即使得重排后图的收缩顺序成为恒等函数。这改善了缓存局部性，我们观察到查询时间因此加快了2到3倍。在本节剩余部分，我们将准备并提供一个理论近似结果。

对于 $\alpha \in (0, 1)$，设 $K_\alpha$ 是一类在图子集构造下封闭的图，且允许基数为 $O(n^\alpha)$ 的平衡分离器 $S$。

**引理 1.** 对于每个 $G \in K_\alpha$，ND 顺序产生的最大搜索空间中的顶点数为 $O(n^\alpha)$。

该引理的证明是使用几何级数的直接论证，如 [6] 中所述。作为直接推论，平均顶点数也是 $O(n^\alpha)$，弧的数量为 $O(n^{2\alpha})$。（注：存在一种方法，用最多 $O(n^\alpha)$ 个顶点（$n$ 是图的总顶点数），就能把图分成两个规模相当的部分。 $\alpha$ 衡量了图“分割的难易程度”，如果是团即完全连通图这个值是 1，像正常道路结构即 0.5 左右。嵌套剖分的过程就像是给图建立一个递归的分治树：爬升的递归深度大约是 $O(\log n)$ 层。在每一层，你遇到的分离器大小都是该层子图规模的 $O(m^\alpha)$）

**引理 2.** 对于每个具有最小平衡分离器 $S$ 的连通图 $G$ 和每个顺序 $\pi$，弦超图 $G^*_\pi$ 都包含一个大小为 $|S|$ 的团。此外，至少存在 $n/3$ 个顶点，使得该团是它们在 $G^\wedge_\pi$ 中搜索空间的子图。

该引理是对 [29] 的轻微调整和扩展，[29] 仅证明了此类团的存在，但未证明其存在于足够多的搜索空间中。我们提供完整证明以保证自包含性。

# 5 Constructing the Contraction Hierarch

在本节中，我们描述如何针对给定的图 $G$ 和顺序 $\pi$ 高效计算层次结构 $G^\wedge_\pi$。加权收缩层次通常使用核心图的动态邻接数组表示来构建。我们的实验表明，该方法也适用于无权情况，但由于捷径数量的更高增长，需要更多的计算和内存资源。有研究提出[42]在动态图结构之上使用哈希表来提高速度，但代价是内存消耗显著增加。在本节中，我们证明在无权无向图上，收缩层次的构建可以显著加快。请注意，在我们的工具链中，图的权重和弧方向是在定制化阶段处理的。

设 $n$ 为 $G$（及 $G^\wedge_\pi$）中的顶点数，$m$ 为 $G$ 中的边数，$\hat{m}$ 为 $G^\wedge_\pi$ 中的弧数，$\alpha(n)$ 为逆阿克曼函数 $A(n, n)$（注：并查集的时间复杂度，近似为 $O(1)$）。为简化问题，我们假设 $G$ 是连通的。我们的方法能在 $O(\hat{m} \alpha(n))$ 的运行时间内枚举 $G^\wedge_\pi$ 的所有弧，其内存消耗为 $O(m)$。存储 $G^\wedge_\pi$ 的弧需要额外的 $O(\hat{m})$ 空间。该方法基于商图方法 [23]。据我们所知，该方法尚未在路径规划的上下文中应用过，并且对于我们所采用的具体变体，尚无现有的复杂度分析。因此，我们将在本节的剩余部分讨论该方法并给出运行时间分析。

回顾一下，为了从给定的输入图 $G$ 和顺序 $\pi$ 计算收缩层次 $G^\wedge_\pi$，需要迭代地收缩每个顶点，并在其邻居之间添加捷径。设 $G' = G_{\pi,i}$ 为第 $i$ 次迭代时的核心图。我们并不显式存储 $G'$，而是采用一种称为收缩图的特殊数据结构，以实现高效的收缩操作和邻居枚举。该收缩图 $H$ 中既包含尚未收缩的核心顶点，也包含一个独立集合的、已虚拟收缩的超顶点，图3展示了这一结构。这些超顶点使我们能够避免动态地向 $G'$ 添加捷径带来的开销。对于 $H$ 中的每个顶点，我们存储一个标记位，指示它是否是一个超顶点。请注意，通过收缩 $H$ 中的所有超顶点即可得到 $G'$。

## 5.1 Contracting Vertices
通过将核心图 $G'$ 中的一个顶点 $x$ 转变为超顶点来完成其收缩。然而，创建新的超顶点可能会破坏独立集性质。我们通过合并相邻的超顶点来恢复该性质：设 $y$ 是一个与 $x$ 相邻的超顶点。我们将 $y$ 关联的所有边重新连接至 $x$，并将 $y$ 从收缩图 $H$ 中移除。

为了支持高效地合并 $H$ 中的顶点，我们为每个顶点存储一个邻居链表。合并两个顶点时，我们将这些链表连接起来。然而，仅合并链表是不够的，因为 $y$ 原来的邻居 $z$ 的邻居链表中仍然包含 $y$。因此，我们额外维护一个并查集数据结构：初始时，每个顶点都在自己独立的集合中。当合并 $x$ 和 $y$ 时，将 $x$ 和 $y$ 所在的集合合并。我们选择 $x$ 作为新集合的代表元，因为 $y$ 已被删除。当顶点 $z$ 枚举其邻居时，它可能会发现一个指向 $y$ 的引用。然后，它可以使用并查集数据结构来确定 $y$ 所在集合的代表元是 $x$。因此，$z$ 链表中的这个引用就被解释为指向 $x$。

合并顶点有可能产生多重边和自环。例如，假设 $y$ 的邻居链表中包含 $x$。合并后，$x$ 合并后的链表因此将包含一个指向 $x$ 自身的引用。类似地，它也会包含一个指向 $y$ 的引用，而查询代表元后发现其实就是 $x$。这样，每次合并会在 $x$ 上产生两个自环。此外，假设有一个顶点 $z$，它同时是 $y$ 和 $x$ 的邻居。在这种情况下，$x$ 的邻居链表将包含两个指向 $z$ 的引用。这些多重边和自环需要被移除。我们采用惰性处理方式，在枚举邻居时移除它们，而不是在合并操作中立即清理。

## 5.2 Enumerating Neighbors

假设我们想要枚举收缩图 $H$ 中顶点 $x$ 的邻居。请注意，$x$ 在 $H$ 中的邻居集与其在核心图 $G'$ 中的邻居集是不同的。$x$ 在 $H$ 中的邻居集可能包含超顶点，因为超顶点仅在 $G'$ 中被收缩。我们维护一个布尔标记位，用于指示哪些邻居已被枚举。初始时，所有标记位均未设置。我们遍历 $x$ 的邻居链表。对于每个引用，我们查找其代表元 $v$。如果 $v$ 已被标记，或者 $v$ 就是 $x$ 自身，则我们将该引用从链表中移除。如果 $v$ 未被标记且不是 $x$，则我们标记它并将其作为一个邻居输出。在枚举完成后，我们通过再次枚举邻居来重置所有标记位。

然而，在我们算法的执行过程中，我们感兴趣的并非 $x$ 在 $H$ 中的邻居，而是 $x$ 在 $G'$ 中的邻居，即算法不应列出超顶点。我们的算法在概念上是先枚举 $x$ 的邻居，然后再收缩 $x$。但我们实际的操作顺序是相反的：我们先收缩 $x$。收缩后，$x$ 成为一个超顶点。由于独立集性质，我们知道 $x$ 在 $H$ 中没有超顶点邻居。因此，我们可以枚举 $x$ 在 $H$ 中的邻居，并利用这一特定情况：此时，$x$ 在 $G'$ 和 $H$ 中的邻居集是完全一致的。

## 5.3 Performance Analysis

由于没有内存分配操作，很明显工作空间的内存消耗为 $O(m)$。证明运行时间为 $O(\hat{m} \alpha(n))$ 则不那么显而易见。用 $d(x)$ 表示顶点 $x$ 在被收缩之前瞬间的度数。$d(x)$ 与 $x$ 在 $G^\wedge_\pi$ 中的向上度数一致，因此有 $\sum d(x) = \hat{m}$。我们首先证明，我们可以将邻居清理操作的开销排除在实际算法的主分析之外。这使我们可以假设在主分析中这些操作是免费的。然后我们证明，收缩一个顶点 $x$ 并枚举其邻居的时间复杂度为 $O(d(x) \alpha(n))$。因此，处理所有顶点的总运行时间为 $O(\hat{m} \alpha(n))$。

顶点 $x$ 的邻居链表可能包含重复的引用，因此其长度可能大于 $x$ 的实际邻居数。此外，对于链表中的每个条目，我们都需要执行一次并查集查询。因此，单次邻居枚举的成本可能超过 $O(d(x)\alpha(n))$。幸运的是，第一次邻居枚举会压缩邻居链表，使得后续的每次枚举都能在 $O(d(x)\alpha(n))$ 时间内完成。移除一个引用的成本为 $O(\alpha(n))$。我们的算法从不添加新的引用。初始时共有 $\Theta(m)$ 个引用。因此，在整个算法过程中，移除引用的总成本为 $O(m\alpha(n))$。由于我们假设图是连通的，有 $m \in O(\hat{m})$，因此 $O(m\alpha(n)) \subseteq O(\hat{m}\alpha(n))$。由此我们可以假设在算法分析中，移除引用操作是免费的。既然移除引用是免费的，我们就可以认为即使是顶点 $x$ 的第一次邻居枚举，其时间复杂度也在 $O(d(x)\alpha(n))$ 之内。合并两个顶点仅涉及在链表中重定向常数数量的引用。因此，合并操作的时间复杂度为 $O(1)$。

我们的算法首先枚举 $x$ 的所有邻居，以确定所有相邻的超顶点，该步骤的时间复杂度为 $O(d(x)\alpha(n))$。相邻的超顶点最多有 $d(x)$ 个，因此将所有超顶点合并到 $x$ 的成本为 $O(d(x))$。随后，我们进行第二次枚举所有邻居的操作，以输出 $G^\wedge_\pi$ 的弧，该第二次枚举的成本同样在 $O(d(x)\alpha(n))$ 之内。由于 $\sum d(x) = \hat{m}$，整个算法的运行时间为 $O(\hat{m}\alpha(n))$，证明完成。

## 5.4 Adjacency Array

尽管上述算法在理论上是高效的，但在实践中，链表会导致过多的缓存未命中。因此，我们实现了一种链表和邻接数组的混合结构，它在最坏情况下具有相同的性能，但在实践中对缓存更友好。这种混合结构中的链表元素不只包含单个引用，而是包含一个小型引用集合，这些引用被组织成称为块的小数组。每个原始顶点的所有邻居构成一个单独的块。因此，初始的链表邻接表由单个块构成。我们通过将它们的块链接在一起来合并两个顶点。如果一个块中的所有引用都被删除，我们将其从链表中移除。

# 6 Enumerating Triangles

一个三角形 ${x, y, z}$ 是三个相互邻接的顶点构成的集合。如图4所示，对于一个弧 $(x, y)$，一个三角形可以是上三角形、中间三角形或下三角形。三角形 ${x, y, z}$ 是弧 $(y, z)$ 的下三角形，当且仅当 $x$ 是三个顶点中秩最低的。类似地，三角形 ${x, y, z}$ 是弧 $(x, y)$ 的上三角形，当且仅当 $z$ 是秩最高的顶点。三角形 ${x, y, z}$ 是弧 $(x, z)$ 的中间三角形，当且仅当 $y$ 的秩介于 $x$ 和 $z$ 的秩之间。一条边 $(a, b)$ 所关联的三角形可以利用顶点 $a$ 和 $b$ 的向上邻居 $N_u$ 与向下邻居 $N_d$ 来表征：存在弧 $(a, b)$ 的一个下三角形 ${a, b, c}$，当且仅当 $c \in N_d(a) \cap N_d(b)$。对于满足 $\pi^{-1}(a) < \pi^{-1}(b)$ 的弧 $(a, b)$，存在一个中间三角形 ${a, b, c}$，当且仅当 $c \in N_u(a) \cap N_d(b)$。存在弧 $(a, b)$ 的一个上三角形 ${a, b, c}$，当且仅当 $c \in N_u(a) \cap N_u(b)$。因此，可以通过求弧的两个端点邻居集合的交集来枚举该弧所关联的三角形。

高效枚举一条弧的所有下三角形，是定制化（第7节）和路径还原（第8节）算法的重要基础操作。该操作既可以使用邻接数组来实现，也可以通过额外的预处理来加速。需要注意的是，除了三角形本身的顶点信息外，我们还对组成三角形的各条弧的ID感兴趣，因为我们需要通过这些ID来获取弧的权重（度量）信息。

**基础三角形枚举** 通过利用邻域交集对三角形进行表征，可以实现高效的三角形枚举。我们为 $G^\wedge_\pi$ 构建一个向上邻接数组和一个向下邻接数组，其中关联的弧分别按照其目标顶点ID和源顶点ID进行排序。一条弧 $(x, y)$ 的下三角形可以通过同时扫描 $x$ 和 $y$ 的向下邻域并确定它们的交集来进行枚举。中间三角形和上三角形可以类似地使用向上邻接数组进行枚举。为了后续能够访问弧的度量（权重）信息，我们还在邻接数组中存储每条弧的ID。这种方法所需的空间与 $G^\wedge_\pi$ 中的弧的数量成正比。

**三角形预处理**
我们提出了一种替代方案，不是按需合并邻域来查找所有下三角形，而是创建一个三角形邻接数组结构。该结构将弧 $(x, y)$ 的ID映射到其每一个下三角形 ${x, y, z}$ 所对应的弧对 $(z, x)$ 和 $(z, y)$ 的ID。这种方法需要与 $G^\wedge_\pi$ 中三角形数量 $t$ 成正比的空间，但允许非常快速的访问。类似的结构也使我们能够高效枚举所有上三角形和所有中间三角形。

**混合方法**
对于结构性较差的图，三角形的数量 $t$ 可能会显著超过 $G^\wedge_\pi$ 中的弧的数量。在最坏情况下，如果 $G$ 是一个完全图，那么三角形数量 $t$ 将达到 $\Theta(n^3)$，而弧的数量仅为 $\Theta(n^2)$。因此，存储所有三角形的列表可能会变得不可行。为此，我们提出了一种混合方法。我们只对满足顶点 $u$ 的层级低于某个特定阈值的弧 $(u, v)$ 预计算其三角形。该阈值是一个权衡空间与时间的可调参数。

**与CRP的比较**
三角形预处理与CRP [16] 中的微码和宏码具有相似之处。下面，我们将这两种方法的空间消耗与我们提出的下三角形预处理方案进行比较。但请注意，在此阶段我们尚未考虑弧上的行驶方向。因此，设 $t$ 为 $G^\wedge_\pi$ 中无向三角形的数量，$m$ 为其弧的数量；再设 $t'$ 为文献[16]中使用的有向三角形的数量，$m'$ 为其弧的数量。如果每条街道都是单行道，则 $m' = m$ 且 $t' = t$；反之，若没有单行道，则 $m' = 2m$ 且 $t' = 2t$。

微码存储一个三元组数组，每个三元组包含指向一个有向三角形中三条弧权重的指针，即它存储了等价于 $3t'$ 个弧ID的空间。计算宏码的确切空间消耗则更为困难。然而，很容易得到一个下界：宏码必须为每个三角形至少存储指向上弧权重的指针。这产生的空间消耗至少等价于 $t'$ 个弧ID。

相比之下，我们的方法为每个三角形存储两条下弧的弧ID。此外，三角形邻接数组的索引数组（将每条弧映射到其下三角形集合）维护着 $m + 1$ 个条目。每个条目的大小相当于一个弧ID。因此，我们的总内存消耗是 $2t + m + 1$ 个弧ID的等价空间。

因此，我们的方法总是比微码需要更少的空间。在单行道稀少的情况下，它与宏码的空间消耗相近；否则，它最多需要两倍的数据量。然而，我们的方法相对于宏码的主要优势在于它允许随机访问，这在后续章节提出的算法中至关重要。


# 7 Customization
到目前为止，我们只考虑了与度量无关的第一预处理阶段。在本节中，我们将描述第二个与度量相关的预处理阶段，即定制化。也就是说，我们将展示如何高效地将输入图的权重扩展为 $G^\wedge_\pi$ 中所有弧对应的一个度量权重。我们考虑顶点间的三种不同距离：我们将输入图 $G$ 中最短的 $s$-$t$ 路径距离记为 $\text{dist}_I(s, t)$。用 $\text{dist}_{UD}(s, t)$ 表示在 $G^\wedge\pi$ 中仅考虑上下路径时的最短 $s$-$t$ 路径距离。最后，用 $\text{dist}_A(s, t)$ 表示在 $G^*_\pi$ 中的最短 $s$-$t$ 路径距离，即允许在 $G^\wedge_\pi$ 中考虑任意（不一定必须是上下）路径时的距离。

为了确保CH查询算法（参见第8节）的正确性，必须满足：对于任意顶点对 $s$ 和 $t$，在 $G^\wedge_\pi$ 中存在一条最短的上下 $s$-$t$ 路径，其距离与输入图 $G$ 中的最短 $s$-$t$ 路径距离相同。换句话说，对于所有顶点 $s$ 和 $t$，必须满足 $\text{dist}_I(s, t) = \text{dist}_A(s, t) = \text{dist}_{UD}(s, t)$。我们称满足 $\text{dist}_I(s, t) = \text{dist}_A(s, t)$ 的度量是尊重输入权重的。如果在此基础上还满足 $\text{dist}_A(s, t) = \text{dist}_{UD}(s, t)$，则我们称该度量为定制化的。请注意，定制化的度量不一定是唯一的。然而，存在一种特殊的定制化度量，称为完美度量 $m_P$，其中对于 $G^\wedge_\pi$ 中的每条弧 $(x, y)$，其权重 $m_P(x, y)$ 都等于最短路径距离 $\text{dist}_I(x, y)$。我们可选择性地使用完美度量来执行完美见证搜索。

构建一个尊重输入权重的度量是简单的：将 $G^\wedge_\pi$ 中已存在于 $G$ 中的弧赋予其输入权重，将所有其他弧的权重赋值为 $+\infty$。计算一个定制化的度量则不那么简单。因此，我们将在第7.1节描述基本定制化算法，该算法在给定一个尊重输入权重的度量的情况下，计算出一个定制化的度量 $m_C$。之后，我们将描述完美定制化算法，该算法在给定一个定制化的度量（例如 $m_C$）的情况下，计算出完美度量 $m_P$。最后，我们将展示如何利用完美度量来执行完美见证搜索。


## 7.1 Basic Customization
基本定制化算法的一个核心概念是下三角不等式，其定义如下：一个度量 $m_C$ 满足该不等式，当且仅当对于 $G^\wedge_\pi$ 中每条弧 $(x, y)$ 的所有下三角形 ${x, y, z}$，都满足 $m_C(x, y) \leq m_C(x, z) + m_C(z, y)$。我们证明：每一个既尊重输入权重又满足此不等式的度量，都是定制化的。我们的算法利用这一点，通过一种协调的方式来转换给定的尊重度量，该方式既保持了尊重属性，又确保了下三角不等式成立。因此，最终得到的度量就是定制化的。我们首先描述该算法，并证明得到的度量是尊重输入权重的且满足该不等式。然后我们证明这足以保证得到的度量是定制化的。

我们的算法以自底向上的方式，按顶点 $x$ 的秩递增的顺序迭代处理 $G^\wedge_\pi$ 中的所有弧 $(x, y)$。对于每条弧 $(x, y)$，它枚举所有下三角形 ${x, y, z}$，并检查路径 $x \to z \to y$ 是否比路径 $x \to y$ 更短。如果是，则它减小 $m_C(x, y)$，使得两条路径等长。形式化地说，它对每条弧 $(x, y)$ 执行操作：$m_C(x, y) \leftarrow \min\{m_C(x, y), m_C(x, z) + m_C(z, y)\}$。请注意，此操作永远不会赋予不与任何路径长度对应的值，因此 $m_C$ 保持尊重输入权重的属性。通过对顶点层级进行归纳，我们可以证明算法结束后，下三角不等式对每条弧都成立，即对于每条弧 $(x, y)$ 及其下三角形 ${x, y, z}$，不等式 $m_C(x, y) \leq m_C(x, z) + m_C(z, y)$ 都成立。关键观察是：根据下三角形的定义，顶点 $z$ 的秩必须严格小于 $x$ 和 $y$ 的秩。因此，在算法处理到弧 $(x, y)$ 时，$m_C(x, z)$ 和 $m_C(z, y)$ 的最终权重已经被计算过了。换句话说，当算法处理弧 $(x, y)$ 时，可以保证权重 $m_C(x, z)$ 和 $m_C(z, y)$ 在算法终止前将保持不变。

**定理 2.**
每一个既尊重输入权重又满足下三角不等式的度量，都是定制化的。

证明：我们需要证明，在任意顶点对 $s$ 和 $t$ 之间，都存在一条最短的上下路径 $s$-$t$。为简化问题，我们假设 $G$ 是连通的，因此从 $s$ 到 $t$ 总存在一条最短路径（不一定非得是上下路径）。如果这条路径本身就是一条上下路径，那么结论自然成立。如果它不是一条上下路径，那么其中必然存在一个子路径 $x \to z \to y$，满足 $\pi^{-1}(x) > \pi^{-1}(z)$ 且 $\pi^{-1}(y) > \pi^{-1}(z)$（即顶点 $z$ 的秩低于 $x$ 和 $y$）（注：这在上下路径中是不允许的，因为上下路径要求路径先严格向上，然后严格向下，中间不能有这样一个“谷底” $z$。）。

由于 $z$ 在 $x$ 和 $y$ 之前被收缩，根据收缩层次的构建原理，边 ${x, y}$（即一条弧 $(x, y)$）必须存在于 $G^\wedge_\pi$ 中（注：即添加了一条 shortcut）。又因为下三角不等式成立，我们有 $m(x, y) \leq m(x, z) + m(z, y)$。因此，将子路径 $x \to z \to y$ 替换为直接路径 $x \to y$ 不会增加整条路径的总长度。现在，替换后的路径要么已经成为一条上下路径，要么我们可以迭代地应用上述论证。由于路径包含的顶点数是有限的，这一过程保证最终能产生定理所要求的上下路径。证明完成。

## 7.2 Perfect Customization

在给定一个定制化度量 $m_C$ 后，我们想要计算完美度量 $m_P$。我们首先将 $m_C$ 的所有值复制到 $m_P$ 中。随后，我们的算法按顶点 $x$ 的秩降序（即自顶向下的方式）迭代处理所有弧 $(x, y)$。对于每条弧，它枚举所有中间三角形和上三角形 ${x, y, z}$，并检查经过 $z$ 的路径是否更短，据此调整 $m_P(x, y)$ 的值。即，它执行操作：$m_P(x, y) \leftarrow \min{m_P(x, y), m_P(x, z) + m_P(z, y)}$。在所有弧都被处理之后，$m_P$ 即为完美度量，如下一定理所示。

**定理 3. ** 在完美定制化完成后，对于每条弧 $(x, y)$，$m_P(x, y)$ 都对应于最短的 $x$-$y$ 路径距离，即 $m_P$ 是完美度量。

证明：我们需要证明，在算法处理完一个顶点 $x$ 之后，它在 $G^\wedge_\pi$ 中的所有出弧都被赋予了最短路径距离的权重。我们通过对已处理顶点的层级进行归纳法来证明这一点。归纳基础：最顶层的顶点（秩最高的顶点）是顶层中唯一的顶点。它没有任何向上弧，因此算法无需对其进行任何操作。这构成了归纳法的基础情况。归纳步骤：在归纳步骤中，我们假设所有层级严格高于当前顶点 $x$ 的顶点都已经被处理完毕。由此，我们知道 $x$ 的向上邻居构成了一个团，并且该团中边的权重已经是最短路径距离。将这些向上邻居记为 $y_i$。这种情况如图5所示。这些 $y_i$ 的权重编码了 $x$ 的向上邻居之间的一个完整的最短路径距离表。

任选一条弧 $(x, y_j)$。我们通过证明以下情况来展示算法的正确性：要么 $m_C(x, y_j)$ 已经是最短路径距离，要么必然存在一个邻居 $y_k \in N_u(x)$，使得 $x \to y_k \to y_j$ 是一条最短的上下路径。（在本段的后续部分，我们假设 $y_k$ 存在，其存在性将在下一段证明。）如果 $m_C(x, y_j)$ 已经是最短的 $x$-$y_j$ 路径距离，那么枚举三角形不会改变 $m_C(x, y_j)$ 的值，因此结果是正确的。如果 $m_C(x, y_j)$ 不是最短的 $x$-$y_j$ 路径距离，那么枚举 $(x, y_j)$ 的所有中间三角形和上三角形，保证能发现 $x \to y_k \to y_j$ 这条路径，因此算法是正确的。其中，上三角形对应于路径中 $y_k$ 的层级高于 $y_j$ 的情况，而中间三角形对应于路径中 $y_k$ 的层级低于 $y_j$ 的情况。

现在需要证明 $x \to y_k \to y_j$ 这条最短上下路径确实存在。由于在完美定制化的每一步中，度量始终是定制化的，我们知道存在一条最短的上下 $x$-$y_j$ 路径 $K$。由于 $K$ 是一条上下路径，我们可以断定 $K$ 的第二个顶点必须是 $x$ 的一个向上邻居。我们将这个邻居记为 $y_k$。因此，$K$ 具有以下结构：$x \to y_k \to \dots \to y_j$。由于 $y_k$ 的秩高于 $x$，$m_P(y_k, y_j)$ 被保证是 $y_k$-$y_j$ 的最短路径距离，因此我们可以将 $K$ 的子路径 $y_k \to \dots \to y_j$ 替换为 $y_k \to y_j$。由此我们证明了所要求的 $x \to y_k \to y_j$ 最短上下路径是存在的，证明完成。

## 7.3 Perfect Witness Search
利用完美定制化算法，我们可以在同一收缩顺序下，高效地计算出具有最少弧数的加权收缩层次。我们提出了算法的两种变体。第一种变体是：移除所有在基本定制化后其权重 $m_C(x, y)$ 不等于最短 $x$-$y$ 路径距离 $m_P(x, y)$ 的弧 $(x, y)$。这种变体简单且总是正确的，但如果输入图中存在顶点对 $a$ 和 $b$ 且它们之间有多条最短路径，则它无法移除尽可能多的弧。第二种变体则可以移除这些额外的弧。一条弧 $(x, y)$ 被移除，当且仅当存在一个上三角形或中间三角形 ${x, y, z}$，使得从 $x$ 经 $z$ 到 $y$ 的最短路径长度不大于 $x$ 到 $y$ 的最短路径长度。然而，在能够证明第二种变体的正确性之前，我们需要引入一些技术工具，这些工具在停滞查询算法的正确性证明中也会用到。我们定义了在 $G^*_\pi$ 中任意路径（不一定是上下路径）的“高度”。我们证明，对于每一个定制化的度量，对于每一条非上下路径，都必然存在一条严格更高且不更长的上下路径。

### 7.3.1 Variant for Graphs with Unique Shortest Paths
第一种算法变体包括：从收缩层次中移除所有满足 $m_P(x, y) \neq m_C(x, y)$ 的弧 $(x, y)$。如果输入图中所有顶点对之间的最短路径都是唯一的，那么这种算法是最优的。如下一定理所表明，这个简单算法是正确的。

**定理 4.** 如果输入图中所有顶点对之间的最短路径都是唯一的，那么我们可以从收缩层次中移除一条弧 $(x, y)$ 当且仅当 $m_P(x, y) \neq m_C(x, y)$。

证明：我们需要证明，在移除所有这类弧之后，对于每一对顶点 $s$ 和 $t$，在剩余的图中仍然存在一条最短的上下路径 $s$-$t$。

我们知道，在移除任何弧之前，存在一条最短的上下路径 $K$。我们证明 $K$ 中没有一条弧会被移除，因此 $K$ 在移除所有弧后依然存在。因为 $K$ 是一条最短路径，所以它的每一个子路径也必然是最短路径。$K$ 中的每一条弧本身就是一个子路径。然而，我们只移除那些满足 $m_P(x, y) \neq m_C(x, y)$ 的弧，即那些本身不是最短路径的弧。

为了证明不能再移除更多的弧，我们需要证明：如果 $m_P(x, y) = m_C(x, y)$，那么路径 $x \to y$ 是唯一的最短上下路径。将 $x \to y$ 这条路径记为 $Q$。假设存在另一条不同的最短上下路径 $R$。$R$ 必须与 $Q$ 不同，即必然存在一个顶点 $z$，它在 $R$ 上但不在 $Q$ 上。由于 $z$ 必须能从 $x$ 到达，我们知道 $z$ 的秩高于 $x$。将路径 $Q$ 在输入图中还原，会得到一条 $x$ 和 $y$ 是秩最高顶点的路径，因此这条还原后的路径不可能包含 $z$。而还原路径 $R$ 则会得到一条包含 $z$ 的路径，因此这两条还原后的路径是不同的。这两条路径都是输入图中从 $x$ 到 $y$ 的最短路径。这与最短路径是唯一的假设相矛盾。

因此我们证明了，如果输入图中的最短路径是唯一的，那么我们可以移除一条弧 $(x, y)$ 当且仅当 $m_P(x, y) \neq m_C(x, y)$。

### 7.3.2 Variant for General Graphs
使用我们算法的第一种变体，即使原始图中的最短路径不唯一，也不会出错。然而，可能会导致一些本可以被移除的弧没有被移除。我们的第二种算法变体则没有这个缺点。

第二种变体会移除所有满足以下条件的弧 $(x, y)$：存在一个中间三角形或上三角形 ${x, y, z}$，使得 $m_P(x, y) = m_P(x, z) + m_P(z, y)$。这些弧在运行完美定制化算法时可以被高效地识别。如果在完美定制化过程中，遇到一个上三角形或中间三角形 ${x, y, z}$ 满足 $m_C(x, y) \geq m_C(x, z) + m_C(z, y)$，那么弧 $(x, y)$ 就会被标记为待移除。

然而，在能够证明第二种变体的正确性之前，我们需要引入一些技术工具。我们希望通过“高度”来对路径进行排序。为此，我们首先为 $G^*_\pi$ 中的每条路径 $K$ 定义其秩序列。我们通过字典序比较这些秩序列来对路径进行排序。用 $v_i$ 表示路径 $K$ 中的顶点。对于 $K$ 中的每条边 $\{v_i, v{i+1}\}$，秩序列包含 $\min\{r(v_i), r(v_{i+1})\}$。秩序列中的数字按递减顺序排列。如果一条路径的秩序列是另一条路径秩序列的前缀，则认为这两条路径具有相同的高度。否则，我们按字典序比较它们的秩序列。图6展示了这种排序方式。我们证明以下技术性引理：

**引理 3**
设 $m_C$ 为某个定制化的度量。对于每一条非上下路径的 $s$-$t$ 路径 $K$，都存在一条上下路径 $s$-$t$ 路径 $Q$，使得 $Q$ 严格高于 $K$，并且相对于 $m_C$，$Q$ 的长度不长于 $K$。

证明：用 $v_i$ 表示路径 $K$ 上的顶点。由于 $K$ 不是上下路径，路径 $K$ 上必然存在一个顶点 $v_i$，其秩低于其相邻顶点 $v_{i-1}$ 和 $v_{i+1}$。$v_{i-1}$ 和 $v_{i+1}$ 是两个不同的顶点，因为它们是某条最短路径的一部分，且不允许零权重存在。

进一步，由于 $v_i$ 在其邻居之前被收缩，在 $v_{i-1}$ 和 $v_{i+1}$ 之间必须存在一条边。又因为度量是定制化的，所以必有 $m_C(v_{i-1}, v_{i+1}) \leq m_C(v_{i-1}, v_i) + m_C(v_i, v_{i+1})$。因此，我们可以将 $v_i$ 从 $K$ 中移除，并用弧 $(v_{i-1}, v_{i+1})$ 替代它，而不会使路径变长。记这条新路径为 $R$。$R$ 高于 $K$，因为我们在秩序列中将 $r(v_i)$ 替换为了 $\min{r(v_{i-1}), r(v_{i+1})}$，而后者必然更大。此时，$R$ 要么已经是一条上下路径，要么我们可以迭代地应用上述论证。在每一次迭代中，路径都会减少一个顶点，因此我们保证最终能得到一条高于 $K$ 且不更长的上下路径。这就是我们期望的、不长于 $K$ 且严格高于 $K$ 的上下路径 $Q$。请注意，这个引理没有利用任何特定于具有度量无关收缩顺序的 CH 的性质，因此它适用于每一个 CH。

有了这个技术性引理，我们就可以证明我们算法第二种变体的正确性了。

**定理 5**
我们可以移除一条弧 $(x, y)$，当且仅当存在一个上三角形或中间三角形 ${x, y, z}$，满足 $m_P(x, y) = m_P(x, z) + m_P(z, y)$。

证明：我们需要证明，对于每一对顶点 $s$ 和 $t$，都存在一条最短的上下 $s$-$t$ 路径，且该路径不使用任何被移除的弧。我们通过证明一条最高的最短上下 $s$-$t$ 路径具有此性质来做到这一点。由于度量是定制化的，我们知道在移除任何弧之前，存在一条最短的上下 $s$-$t$ 路径 $K$。如果 $K$ 不包含任何满足条件（即存在三角形使得 $m_P(x, y) = m_P(x, z) + m_P(z, y)$）的弧 $(x, y)$，那么无需证明。否则，我们修改 $K$：在 $x$ 和 $y$ 之间插入 $z$。这不会改变 $K$ 的长度，但我们不能再保证 $K$ 是一条上下路径。如果 ${x, y, z}$ 是一个中间三角形，那么 $K$ 仍然是一条上下路径。并且它严格更高，因为我们在秩序列中加入了 $r(z)$，而 $r(z)$ 保证大于 $r(x)$。如果 ${x, y, z}$ 是一个上三角形，那么 $K$ 不再是一条上下路径。幸运的是，利用引理 3，我们可以将 $K$ 转换为一条上下路径，该路径不更长且严格更高。在两种情况下，新的 $K$ 要么已经是一条上下路径，要么我们可以迭代地应用上述论证。由于在每次迭代中 $K$ 都变得严格更高，并且上下路径的数量是有限的，我们知道最终将获得一条最短的上下 $s$-$t$ 路径，其中没有弧可以被移除。

此外，我们需要证明，如果不存在这样的三角形，那么一条弧不能被移除，即我们需要证明从 $x$ 到 $y$ 的唯一最短上下路径就是仅由弧 $(x, y)$ 组成的路径。假设不存在这样的三角形，但存在另一条不同的上下路径 $Q$。$Q$ 必须包含除 $x$ 和 $y$ 之外的顶点，并且 $Q$ 中的所有顶点秩都必须等于或高于 $x$ 的秩。考虑 $Q$ 中紧接 $x$ 之后的顶点 $z$。由于 $x$ 在 $z$ 和 $y$ 之前被收缩，$z$ 和 $y$ 之间必须存在一条弧。因此，必然存在一个三角形 ${x, y, z}$：如果 $z$ 的秩低于 $y$，它是一个中间三角形；如果 $z$ 的秩高于 $y$，它是一个上三角形。然而，我们假设了不存在这样的三角形。这就产生了矛盾。因此，我们证明了，我们可以移除一条弧 $(x, y)$ 当且仅当存在一个上三角形或中间三角形 ${x, y, z}$ 满足 $m_P(x, y) = m_P(x, z) + m_P(z, y)$。

## 7.4 Parallelization
基本定制化算法可以通过并行处理同一层级内出发的弧 $(x, y)$ 来实现并行化。在不同层级之间，我们需要使用屏障来同步所有线程。由于所有线程仅写入当前分配给它们的弧，并且仅读取在严格更低层级已处理过的弧，因此我们可以保证不会发生读/写冲突。因此，不需要使用锁或原子操作。

在现代大多数处理器上，完美定制化可以按照与基本定制化算法类似的方式进行并行化。然而，理解其正确性并非显而易见，因为线程执行的确切顺序会影响中间结果。幸运的是，最终结果总是相同的，并且与执行顺序无关。我们的算法工作方式如下：我们并行地迭代处理同一层级内出发的所有弧，并在不同层级之间同步所有线程。对于每条弧 $(x, y)$，我们枚举所有上三角形和中间三角形，并相应地更新 $m_P(x, y)$。考虑图5所示的情况。假设线程 A 正在处理弧 $(x, y_A)$，同时线程 B 正在处理弧 $(x, y_B)$。进一步假设，在线程 B 枚举三角形 ${x, y_B, y_A}$ 的同一时刻，线程 A 正在更新 $m_P(x, y_A)$。在这种情况下，线程 B 将看到什么值是不明确的。然而，只要保证线程 B 要么看到旧值，要么看到新值，我们的算法就是正确的。

在定理3的证明中，我们已经表明，对于每个顶点 $x$ 和弧 $(x, y_i)$，要么该弧 $(x, y_i)$ 已经具有最短路径距离，要么存在一个上三角形或中间三角形 ${x, y_i, y_j}$，使得 $x \to y_j \to y_i$ 是一条最短路径。无论线程以何种顺序处理这些弧，它们都不会修改最短路径权重。这意味着，无论执行顺序如何，最短路径 $x \to y_j \to y_i$ 都会被保留。这条最短路径不会被修改，并且保证在处理当前层级发出的任何弧之前就已经存在。因此，每个线程都保证能看到它。然而，其他权重可能会被修改。幸运的是，只要我们能保证没有线程会看到一个低于相应最短路径距离的值，这就不是问题。因此，如果我们能保证线程B要么看到旧值，要么看到新值（正如在 x86 处理器上的情况），那么算法就是正确的。如果线程B可能看到旧值和新值的某些错位混合的位组合，那么我们就需要使用锁，或者确保所有从 $x$ 发出的弧都由同一个线程处理。

## 7.5 Directed Graphs

到目前为止，我们主要关注于无向图的定制化。如果输入图 $G$ 是有向的，我们的工具链工作流程如下：预处理阶段（与方向无关）：基于 $G$ 所对应的无向无权图，我们计算一个顶点顺序 $\pi$（第4节）。构建向上有向的收缩层次 $G^\wedge_\pi$（第5节）。（可选）执行三角形预处理（第6节）。定制化阶段（考虑方向）：对于 $G^\wedge_\pi$ 中的每条弧，我们考虑两个权重，分别对应两个行驶方向。单行街道通过将禁止通行方向的权重设置为 $\infty$ 来建模。根据顺序 $\pi$，我们在 $G^\wedge_\pi$ 上定义一个向上度量 $m_u$ 和一个向下度量 $m_d$。权重分配规则：对于输入有向图 $G$ 中的每条弧 $(x, y)$（其输入权重为 $w(x, y)$）：如果 $\pi^{-1}(x) < \pi^{-1}(y)$（即 $x$ 的秩低于 $y$），则设置 $m_u(x, y) = w(x, y)$。否则，设置 $m_d(x, y) = w(x, y)$。$m_u$ 和 $m_d$ 的所有其他值都初始化为 $\infty$。换句话说：收缩层次 $G^\wedge_\pi$ 中的每条弧 $(x, y)$：其向上权重 $m_u(x, y) = w(x, y)$，当且仅当 $(x, y)$ 是原始有向图 $G$ 中的一条弧且 $x$ 的秩低于 $y$。其向下权重 $m_d(x, y) = w(y, x)$，当且仅当 $(y, x)$ 是原始有向图 $G$ 中的一条弧且 $y$ 的秩低于 $x$。否则，相应的权重为 $\infty$。

基本定制化同时考虑两个度量 $m_u$ 和 $m_d$。对于 $(x, y)$ 的每一个下三角形 ${x, y, z}$（注：$z$ 的秩最低），它设置 $m_u(x, y) \leftarrow \min\{m_u(x, y), m_d(x, z) + m_u(z, y)\}$ 和 $m_d(x, y) \leftarrow \min\{m_d(x, y), m_u(x, z) + m_d(z, y)\}$。完美定制化可以类似地调整。对于 $(x, y)$ 的每一个中间三角形 ${x, y, z}$，完美定制化设置 $m_u(x, y) \leftarrow \min\{m_u(x, y), m_u(x, z)+m_u(z, y)\}$ 和 $m_d(x, y) \leftarrow \min\{m_d(x, y), m_d(x, z) + m_d(z, y)\}$。类似地，对于 $(x, y)$ 的每一个上三角形 ${x, y, z}$，完美定制化设置 $m_u(x, y) \leftarrow \min{m_u(x, y), m_u(x, z)+m_d(z, y)}$ 和 $m_d(x, y) \leftarrow \min{m_d(x, y), m_d(x, z) + m_u(z, y)}$。

完美见证搜索可能只需要移除一个方向上的弧。因此，正如在原始收缩层次中一样，它产生两个搜索图：一个向上搜索图和一个向下搜索图。查询阶段的前向搜索仅限于向上搜索图，后向搜索仅限于向下搜索图，与原始收缩层次中一样。弧 $(x, y)$ 从向上搜索图中被移除，当且仅当存在一个中间三角形 ${x, y, z}$ 满足 $m_u(x, y) = m_u(x, z) + m_u(z, y)$ 或存在一个上三角形 ${x, y, z}$ 满足 $m_u(x, y) = m_u(x, z) + m_d(z, y)$。类似地，弧 $(x, y)$ 从向下搜索图中被移除，当且仅当存在一个中间三角形 ${x, y, z}$ 满足 $m_d(x, y) = m_d(x, z) + m_d(z, y)$ 或存在一个上三角形 ${x, y, z}$ 满足 $m_d(x, y) = m_d(x, z) + m_u(z, y)$。

## 7.6 Single Instruction Multiple Data

收缩层次中每条弧附带的权重可以被一组交错的 $k$ 个权重所替代，具体实现方式是为每条弧存储一个包含 $k$ 个元素的向量。向量允许我们一次性定制所有 $k$ 个度量，从而分摊三角形枚举的时间成本，并且允许我们使用单指令多数据流操作。此外，由于我们本质上使用两个度量来处理有向图，我们可以将它们存储在一个 2 维向量中。这使得我们能够在单个处理器指令中处理两个方向。类似地，如果我们有 $k$ 个有向输入权重，我们可以将它们存储在 $2k$ 维向量中。

处理器需要支持逐分量最小值和饱和加法操作，即在发生溢出时，必须满足 a + b = int_max。对于有向图的情况，处理器还需要支持高效地交换相邻的向量分量。当前支持 SSE 的处理器能够支持所有针对 16 位整数分量的必要操作。但对于 32 位整数，缺少饱和加法指令。有两种方法可以解决这个限制：第一种方法是使用常规加法、比较和混合/条件选择指令的组合来模拟饱和加法。第二种方法是使用 31 位权重，并用 $2^{31} - 1$ 作为 $\infty$ 的值，而不是 $2^{32} - 1$。该算法仅计算两个权重的饱和加法，然后取结果与另一个权重的最小值，即，如果计算所有权重 a, b 和 c 的 min(a + b, c) 没有问题，那么算法就能正确工作。我们知道 a 和 b 最大为 $2^{31} - 1$，因此它们的和最大为 $2^{32} - 2$，这可以放入一个 32 位整数中。在下一步中，我们知道 c 最大为 $2^{31} - 1$，因此最终的最小值也最多为 $2^{31} - 1$。

## 7.7 Partial Updates

到目前为止，我们只考虑了从头开始计算度量的情况。然而，在许多场景中，这是不必要的，因为我们知道只有输入图中少数几条边的权重发生了改变。在这种情况下，重新进行所有计算是多余的。我们算法所采用的思想与[21]中提出的方法有些相似，但我们的情况不同，因为我们知道不需要插入或移除弧。用 $U = {((x_i, y_i), w^{\text{new}}_i)}$ 表示需要更新权重的弧的集合，其中 $(x_i, y_i)$ 是弧 ID，$w^{\text{new}}_i$ 是新的权重。请注意，修改一条弧的权重可能引发进一步的更改。然而，这些新的更改必须发生在更高的层级。因此，我们将 $U$ 组织成一个优先队列，按照 $x_i$ 的层级排序。我们迭代地从队列中移除弧并应用更改。如果触发了新的更改，我们将其插入队列。当队列为空时，算法终止。

设 $(x, y)$ 为从队列中移除的弧，$w^{\text{new}}$ 为其新权重，$w^{\text{old}}$ 为其旧权重。首先，我们需要检查 $w^{\text{new}}$ 是否可以通过某个下三角形被“绕行”。为此，我们迭代处理 $(x, y)$ 的所有下三角形 ${x, y, z}$，并执行 $w^{\text{new}} \leftarrow \min\{w^{\text{new}}, m(z, x) + m(z, y)\}$。此外，如果 ${x, y}$ 是输入图 $G$ 中的一条边，我们可能之前已用某个捷径权重覆盖了其原始权重，而在本次更新后，这个覆盖的权重可能不再是较短的了。因此，我们额外测试 $w^{\text{new}}$ 是否不大于其输入权重。如果经过这两项检查后，有 $w^{\text{new}} = m(x, y)$ 成立，则无需进行更改，也不会触发进一步的更改。如果 $w^{\text{old}}$ 和 $w^{\text{new}}$ 不同，我们则迭代处理 $(x, y)$ 的所有上三角形 ${x, y, z}$，并测试是否有 $m(x, z) + w^{\text{old}} = m(y, z)$ 成立；如果成立，则必须将弧 $(y, z)$ 的权重设置为 $m(x, z) + w^{\text{new}}$。我们将此更改加入队列。类似地，我们迭代处理 $(x, y)$ 的所有中间三角形 ${x, y, z}$，如果 $m(x, z) + w^{\text{old}} = m(z, y)$ 成立，则将 $(z, y)$ 的更改排队。

单个更改所触发的后续更改数量在很大程度上取决于度量本身，并且可能有显著差异。略微改变一条土路的权重几乎不会产生任何影响，而更改一条繁忙高速公路段的权重则会触发许多更改。在游戏设定中，这种运行时间差异巨大的情况是不可取的，因为它会导致卡顿峰值。我们提议维护一个队列，所有更改都被插入该队列中。每一轮分配固定的时间来处理此队列中的元素。如果在队列清空之前时间耗尽，则剩余的弧将在下一轮处理。通过这种方式，成本被分摊，从而实现了每回合恒定的工作量。缺点是，只要队列非空，某些距离查询将使用过时的数据。每回合用于更新度量的时间决定了将一个更新传播到整个图所需的时间。


# 8 Distance Query

在本节中，我们将描述如何计算距离查询，即在给定定制化度量的情况下，计算 $G^\wedge_\pi$ 中两个顶点 $s$ 和 $t$ 之间的最短上下路径，以及如何将其还原为 $G$ 中的最短路径边序列。

## 8.1 Basic

基础查询在 $G^\wedge_\pi$ 上从 $s$ 和从 $t$ 分别运行两个 Dijkstra 算法实例。如果 $G$ 是无向图，则两个搜索使用相同的度量。否则，如果 $G$ 是有向图，则从 $s$ 出发的搜索使用向上度量 $m_u$，从 $t$ 出发的搜索使用向下度量 $m_d$。无论哪种情况，与 [21] 不同的是，它们都在同一个向上搜索图 $G^\wedge_\pi$ 上操作。一旦其中一个搜索的半径（即当前从起点/终点出发探索到的最大距离）超过了目前已找到的最短路径的长度，我们就停止该搜索，因为我们知道不可能存在更短的路径了。我们在处理前向搜索的顶点和处理后向搜索的顶点之间交替进行。

## 8.2 Stalling
我们实现了[21, 33]中提出的一种称为按需停滞的优化的基础版本。该优化利用了这样一个事实：$G^\wedge_\pi$ 中最短的严格向上 $s$-$v$ 路径可能长于 $G^*_\pi$ 中最短的 $s$-$v$ 路径，后者可以任意地上下行走。从 $s$ 出发的搜索仅能找到向上路径，而如果我们观察到存在一条不更长的上下路径，那么我们就可以剪枝该向上搜索。设 $x$ 为从队列中移除的顶点。我们迭代所有出弧 $(x, y)$，并测试是否满足 $d(x) \geq m(x, y) + d(y)$。如果该条件对某条弧成立，我们则通过不松弛其出弧来剪枝 $x$。

如果 $d(x) > m(x, y) + d(y)$ 成立，那么剪枝是正确的，因为最短上下路径的所有子路径本身也必须是最短路径，而终止于 $x$ 的这条向上路径并不是最短路径，因为存在一条经过 $y$ 的更短的上下路径。当 $d(x) \geq m(x, y) + d(y)$ 时，我们也可以进行剪枝，但这需要不同的论证。据我们所知，对于 $d(x) = m(x, y) + d(y)$ 的情况，其正确性迄今尚未被证明。请注意，我们并未利用度量无关顺序的任何特殊性质，因此我们的证明适用于每一个收缩层次。

**定理 6**
当 $d(x) \geq m(x, y) + d(y)$ 成立时，可以剪枝向上搜索。

证明：我们证明对于任意顶点对 $s$ 和 $t$，都存在一条不可剪枝的、最短的上下 $s$-$t$ 路径。我们的证明依赖于引理 3，该引理通过高度对路径排序，并指出非上下路径的 $s$-$t$ 路径可以转换为不更长且严格更高的上下路径。我们知道存在某条最短 $s$-$t$ 路径 $K$。如果 $K$ 没有被剪枝，则无需证明。如果 $K$ 被剪枝了，那么路径 $K$ 上存在一个顶点 $x$，在该点处搜索被剪枝。不失一般性地，我们假设 $x$ 位于 $K$ 的向上部分。此外，必然存在一个顶点 $y$ 和一条经过 $y$ 的从 $s$ 到 $x$ 的路径 $Q$，使得 $Q$ 不长于 $K$ 的 $s$-$x$ 前缀。考虑通过将 $Q$ 与 $K$ 的 $x$-$t$ 后缀拼接而得到的路径 $R$。根据构造，$R$ 不长于 $K$。如果 $x$ 是 $K$ 上的最高顶点，那么 $R$ 是一条上下路径并且 $R$ 严格更高。否则，$R$ 不是一条上下路径，但使用引理 3，$R$ 可以被转换为一条严格更高且不更长的上下路径。在这两种情况下，$R$ 都不更长且严格更高。要么 $R$ 是不可剪枝的，要么我们迭代地应用此论证。由于只存在有限条上下路径，并且每次迭代都增加了 $R$ 的高度，我们最终会得到一条不可剪枝的、最短的上下 $s$-$t$ 路径，这完成了证明。

## 8.3 Elimination Tree

我们在预处理步骤中为每个顶点预计算其在消除树中的父顶点ID。这使我们能够在查询时高效地枚举 $SS(s)$ 和 $SS(t)$ 中的所有顶点。顶点按秩递增的顺序被枚举。

我们存储两个暂定距离数组 $d_f(v)$ 和 $d_b(v)$。初始时，它们都被设置为 $\infty$。第一步：我们计算 $s$ 和 $t$ 在消除树中的最低共同祖先 $x$。我们通过同时按秩递增的顺序枚举 $s$ 和 $t$ 的所有祖先，直到找到一个共同的祖先来实现这一点。第二步：我们迭代遍历从 $s$ 到 $x$ 的树路径上的所有顶点 $y$，并松弛此类 $y$ 的所有前向弧。第三步：我们在后向搜索中，对从 $t$ 到 $x$ 的所有顶点 $y$ 执行相同的操作。第四步：我们迭代遍历从 $x$ 到根节点 $r$ 的所有顶点 $y$，并松弛所有前向弧和后向弧。此外，在第四步中，我们还确定使得 $d_f(z) + d_b(z)$ 最小的顶点 $z$。

必然存在一条经过 $z$ 的最短上下路径。要知道 $z$ 对于确定最短路径距离和计算构成最短路径的弧序列是必要的。在第五个清理步骤中，我们迭代遍历从 $s$ 和 $t$ 到根节点 $r$ 的所有顶点，以将所有 $d_f$ 和 $d_b$ 重置为 $\infty$。这第五步避免了为每个查询花费 $O(n)$ 的运行时间来将所有暂定距离初始化为 $\infty$。考虑图 7 所描绘的情况。在第一步中，算法确定了 $x$。在第二步中，它松弛了所有虚线弧以及从浅灰色区域出发的树弧。在第三步中，处理所有虚点线弧以及从中灰色区域出发的树弧；在第四步中，处理实线弧以及剩余的树弧。



