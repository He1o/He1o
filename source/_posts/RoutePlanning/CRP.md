---
title: Customizable Route Planning
date: 2025-07-13
category: Route Planning
---
<!--more-->

# 算法

首先定义一个图(graph) $G=(V,A)$, 具有非负的代价函数(cost function) $\ell (v,w)$ 与每条弧(arc) $(v,w) \in A$，一条路径 $P=(v_0,\dots,v_k)$ 是一系列顶点的集合 $(v_i,v_{i+1}\in A)$，并且它的成本定义为 $\ell (P)=\sum^{k-1}_{i=0}$，给定一起点 $s$ 和一个终点 $t$，我们找到它们之间的距离 $dist(s,t)$ 定义为 $s$ 到 $t$ 最短路径的长度 $\ell(Opt)$。

*dijkstra* 的时间复杂度 $O(m+n\log n),n=|V|,m=|A|$ 

## Partitions

定义一个 $V$ 的分区(partition) 是一个 *cells* 的集合 $\mathcal{C}=\{C_0,\dots,C_k\}，C_i\in V$，每个 $v\in V$ 包含在一个 $C_i$ 中，定义 $U$ 是其中最大的 $cell$，一个 $V$ 的多级分区是一个分区族 $\{\mathcal{C}^0,\dots,\mathcal{C}^L\}$，其中 $l$ 代表一个分区 $\mathcal{C}^l$ 的等级，而 $U^l$ 代表这个等级下最大的 $cell$ 的大小。我们设置 $U^0=1,i,e$，即等级 0 只包含一个单例。为了简化定义，同时设置 $\mathcal{C}^{L+1}=V$。

使用嵌套的多级分区，即对每个 $l\le L$ 并且每个 $cell$ $C_i^l\in \mathcal{C}^l$，都存在一个 $cell$ $C_j^{l+1}\in \mathcal{C}^{l+1}$，称为 $C_i^l$ 的 $supercell$，存在 $C_i^l\subseteq C_j^{l+1}$，相反的，我们称 $C_i^l$ 是 $C_j^{l+1}$ 的 $subcell$。注意我们用 $L$ 定义级别的数量，并且 $L$ 等级的 $supercell$ 是 $V$。我们用 $c_l(v)$表示包含 节点 $v$ 且等级为 $l$ 的 $cell$，为了简化符号，当 $L=1$ 时我们使用 $c(v)$ 而不是 $c_1(v)$。一个在等级 $l$ 的边界弧 (boundary arc) 的顶点在具有在等级为 $l$ 的不同 $cell$ 中，一个等级 $l$ 的边界节点 (boundary vertex) 至少具有一个相邻节点在其它的等级 $l$ 的 $cell$ 中。对于嵌套的多级分区，边界弧也嵌套了，等级为 $l$ 的边界弧同时也是下面所有级别的边界弧。

## Basic Algorithm
基于分区的覆盖图(overlay graph)的预处理加速技术，首先找到输入图的分区，然后构建包含原始图 $G$ 的所有边界弧和边界顶点的生成图 $H$，然后为它的每个 $cell$ 构建一个集团 $clique$，对于 $C$ 的每个边界顶点对 $pair(v,w)$，创建一个弧 $(v,w)$，并且它的成本和 $v$ 和 $w$ 之间的最短路一样(仅限制于 $C$ 中搜索)，如果 $w$ 不可到达，则使用无穷大。通过对于每个边界顶点运行 $dijkstra$ 来确定这些便捷弧(shortcut arcs)的成本。

**定理 1** $H$ 是 $G$ 的一个 $overlay$

*证明* 对于任意两个顶点 $u,v$，我们必须证明它们之间的距离在 $G$ 和 $H$ 中是一样的，即 $dist_G(u,v)=dist_H(u,v)$。通过构造，我们在 $H$ 中添加了一条路径且与在 $G$ 中的 $cost$ 相同，因此对于所有 $u,v\in H$ $dist_H(u,v)\ge dist_G(u,v)$ (距离不会减少)。考虑到 $G$ 中 $u$ 和 $v$ 之间的最短路 $P_{uv}$，可以被看做连续边界顶点之间的子路的序列，这些子路径中的每一条边都是边界弧 (通过构造属于 $H$)，或者是一条在 $cell$ 中两个边界节点的最短路 (同样通过构造创建了一条便捷边在 $H$)，这意味着在 $H$ 中存在一条路径和 $P_{uv}$ 的代价一样，保证了 $dist_H(u,v)\le dist_G(u,v)$。

请注意，即使在 $H$ 中添加了一些 $shortcut$ 并不是 $G$ 或 $H$ 的最短路径，这个定理仍然存在，此类 $shortcut$ 是多余的，但不会影响正确性。

$s$ 和 $t$ 之间执行一个查询，运行在一个由 $H,c(s),c(t)$ 联合的搜索图上，通过双向 *dijkstra* 算法，只要 $H$ 是 $G$ 的 $overlay$ 就可以确保查询准确。直观地，考虑到 $s$ 到 $t$ 的最短路径由三部分组成 $c(s)$ 的最大前缀，$c(t)$ 的最大后缀，以及其余的中间部分。通过构造 $c(s)$ 和 $c(t)$ 是搜索空间的一部分，并且 $H$ 包含与代表中间部分的路径相同成本的路径，具有相同的起止点。因为覆盖图不会降低任意两个顶点间的最短路径，因此我们找到了一个在 $G$ 等价的路径成本。

为了加速查询，基于分区的方法通常使用多个级别的覆盖图。对于每个等级 $i$ 的分区，都像之前一样构建图 $H_i$，它包含油油的边界弧，以及一个链接 $cell$ 中的边界顶点的覆盖层。如果以自下而上的方式构建覆盖层，则可以通过 $H_{i-1}$ 来运行 *dijkstra* 来计算 $H_i$ 边界顶点的距离，而不是 $G$。这加速了高等级覆盖图的计算，在查询期间，可以跳过不包含 $s$ 和 $t$ 的 $cell$。更准确的说，一个 $s-t$ 的搜索运行在受限的搜索图 $G_{st}$ 上，一个 $H_i$ 的弧 $(v,w)$ 只有 $v$ 和 $w$ 在同一个 $cell$ 或者 $s$ 或 $t$ 同时在更高一级 $i+1$ 时，这个弧才会在这个搜索图中。

##  Pruning the Overlay Graph

s