# 1 信息层-数据存储
## 1.1 二进制和记数系统
基数（base）：记数系统的基本数值，规定了这个系统中使用的数字量和数位位置的值。

位置记数法（positional notation）：一种表达数字的系统，数位按顺序排列，每个数位又一个位置，数字的值是每个数位和位值的乘积之和，即用记数系统的基数的多项式表示值。

不同进制之间的相互转换

* 二进制数字（binary digit）：二进制记数系统中的一位数字，可以是0或1，在计算机中每个存储位为高电平和低电平两种信号，每个存储单元即为一个二进制数字。
* 位（bit）：二进制数字的简称。
* 字节（byte）：8个二进制位。
* 字（word）：一个或多个字节，字中的位数称为计算机的字长

## 1.2  数据形式
计算机可以处理各种各样的信息，可以存储、表示和帮助我们修改各种类型的数据
* 数据（data）：基本值或事实，未组织过的，缺少context，
* 信息（information）：用有效的方式组织或处理过的数据，可以帮助我们回答问题。
* 多媒体（multimedia）：集中不同的媒体类型。
* 数据压缩（data compression）：减少存储一段数据所需的空间。
* 带宽（bandwidth）：在固定时间内从一个地点传输到另一个地点的最大位数或字节数。
* 压缩率（compression ratio）：压缩后的数据大小除以原始数据大小的值。
* 无损压缩（lossless compression）：不会丢失信息的数据压缩技术。
* 有损压缩（lossy compression）：会丢失信息的数据压缩技术。

表示数据的方法有两种，模拟法和数字法。模拟数据是一种连续表示法，模拟它表示的真实信息，数字数据是一种离散表示法，把信息分割成独立的元素。模拟数据完全对应于我们周围无限连续的世界。因此，计算机不能很好的处理模拟数据，需要数字化数据，即把信息分割成片段并单独表示每个片段。
数字信号只能在两个极端之间跳跃，称为脉冲编码调制（PCM）。数字信号在信息丢失之前会降级相当多，因为大于某个阈值的电平值被看作高电平。数字信号会被周期性重新计时，以恢复到它的原始状态。

1.3  数字数据表示法
1.3.1  负数表示法
符号数值表示法 signed-magnitude representation，符号表示数所属的分类（正数或负数）、值表示数的量值的数字表示法。对带符号的整数执行加减法可以被描述为向一个方向或另一个方向移动一定数字单位。符号数值表示法存在问题，即表示0的方法有两种，+0或-0，在计算机中会引起不必要的麻烦。
十进制补码 （ten’s complement），一种负数表示法，负数I用10的k次幂减I表示。




二进制补码（ two’s complement），位模式最左边的二进制位指明了所表示的数值的符号，0为正，1为负（指明符号的同时，0变为1，也可以理解为在数的基础上加2^n，例如八位中，0加上了128，则用128表示-128，127加上128，则用255表示-1。因此，在二进制补码中11111111，不表示-127，而是表示-1）。假定数字只能用八位表示，七位表示数值，一位表示符号，则取值范围为-128～127。与十进制补码相类似：
-2 = 2^7 - 2 = 128 - 2 = 126
十进制数126用二进制表示为1111110，左边添加一位符号位变为11111110。
除了用公式计算，在二进制中还有更简单的方法计算二进制补码，当知道5的二进制数，如何得到-5的二进制数？
方法一：将每一位取反再加一
5:  00000101
取反：11111010
    +1：11111011 = 251
方法二：从右向左，直到第一个二进制1（包括），他们都是相同的。然后，以这个1为分界线，左面的位模式取反。
5:  00000101
-5:  11111011
二进制补码的加减法：二进制补码记数法的一个主要优点在于，减法可以转化为加法，从而可以使用相同的电路来实现。7-5与7+（-5）是一样的。因此，在计算机中执行7（0111）减去5（0101），将5转换为-5（1011），再执行0111+1011=0010=2。
溢出（overflow）：当给结果预留的位数存不下计算出的值的状况时。在二进制补码记数法中，如果两个正值相加的结果是负值，或者两个负值相加的结果为正，那么就发生了溢出问题。
127+3 ：01111111+00000011=10000010   在二进制补码中，第一位是符号位结果为-126。但如果表示的不是负数时，结果就是130将是正确的。
余码计数法（excess notation）
1.3.2  实数表示法
在计算中，非整数的值称为实值。实数具有整数部分和小数部分，每个部分都可能是0。位置记数法中，数字的位置表示数值，位值是由基数决定的。在十进制中，小数点左侧的位值有1、10、100等等，它们都是基数的幂，从小数点开始向左，每一位升高一次幂。小数点右侧的位值同样如此，只不过幂是负数。所以小数点右侧的位置是十分位（10^-1或十分之一）、百分位（10^-2或百分之一）。同理，在二进制中，小数点右侧的位置是二分位、四分位，以此类推。
一种基于科学计数法的存储方法，称为浮点记数法。任何实值可以由三个属性描述，即符号、指数和尾数，尾数由该数值中的数字构成，指数确定了小数点相对于尾数的位移。数字的个数是固定的，小数点却是浮动的，因此称为浮点记数法。在用浮点形式表示的数值中，正指数将把小数点右移，负指数将小数点左移。
假如一个字节由位模式01101011组成，符号为0，指数是110，尾数是1011。解码，尾数左边放置一个小数点，得到.1011，指数110是一个三位的二进制补码，表示整数2，因此小数点右移2位，可以得到10.11=1*2+0*1+1*1/2+1*1/4=2.75。
截断误差（truncation error）：由于尾数域空间不够大，而导致的存储部分数值丢失。二进制中的无穷展开式多于十进制，在二进制中无法精确表示1/10。
单精度浮点（single precision floating point）记数法，具有32位，其中1位表示符号位、8位表示指数、23位表示尾数。因此，单精度浮点最多有7位十进制有效数字，可以表示10^32到10^-37数量级之间的数，也就是说，可以精确地存储前七位十进制有效数字。
双精度浮点（double precision floating point）记数法，具有64位，最多有15位十进制有效数字。
科学计数法（scientific notation）是浮点表示法的一种形式，小数点总在最左边数字的右侧，也是说只有一位整数部分，12001.32708被写为1.200132708E+4。
1.4  文本表示法
1.4.1  ASCII字符集
字符集（character set）：字符和表示它们的代码的清单
ASCII字符集（American Standard Code for Information Interchange），用7位表示每个字符，可以表示128个字符，
0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 [1]  。
32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。
65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。
1.4.2 Unicode字符集
Unicode每个字符的编码为16位，但如果需要每个字符也可以使用更多空间，以便表示额外的字符。Unicode字符集的一个方便之处是把ASCii字符集作为一个子集，即前256个字符与扩展ASCii字符集中的完全一样。因此，即使底层系统采用Unicode字符集，采用ASCii值的程序也不会受到影响。
1.4.3 文本压缩
文本压缩主要有三种方式
关键字编码（keyword encoding）：用单个字符代替常用的单词。例如用^替代as，~替代the等等。这种方式有一些局限性。首先，用来编码的字符不能出现在原始文本中，否则会产生歧义；其次，The不会被编码，因为大小写是不同的字符；最后常用的单词都比较短，节省空间有限，而长的单词出现频率低也没有替换的必要。
行程长度编码（run-length encoding）：把一系列重复字符替换为它们重复出现的次数。将重复字符的序列替换为标志字符，后面加重复字符和说明字符重复次数的数字，例如AAAAAAA可以替换为*A7，*即为一种标志字符。因为用一个字符记录重复的次数，看似不能对重复次数大于9的序列编码，但实际上，在字符集中一个字符是由多个为表示的，因此可以将次数字符解释为一个二进制数，而不是ASCii数字。因此，能够编码的重复字符重复次数可以是0~255。
赫夫曼编码（Huffman encoding）：用变长的二进制串表示字符，使常用的字符具有较短的编码。不同的字符编码长度不同，例如常出现的A编码00，而出现比较少的D则为1011。由于编码是变长的，因此不知道每个字符对应多少位编码，看似很难将一个字符串解码。赫夫曼编码的一个重要特征是用于表示一个字符串的位串不会是另个一字符的位串的前缀。因此，从左到右扫描一个位串时，每当发现一个位串对应于一个字符，那么将唯一对应，不会发生歧义。


